---
layout: default
title: HOLOQ - Personal Intelligence Agency
show_pyramid: true
---

<div class="consciousness-toggle">
  <button class="toggle-btn active" data-mode="professional">LEVEL-HEADED</button>
  <button class="toggle-btn" data-mode="consciousness">REAL</button>
</div>

<div id="professional-content" class="content-mode active">
  {% capture professional %}{% include_relative professional.md %}{% endcapture %}
  {{ professional | markdownify }}
</div>

<div id="consciousness-content" class="content-mode">
  {% capture consciousness %}{% include_relative BOMB.md %}{% endcapture %}
  {{ consciousness | markdownify }}
</div>

<style>
.scrambling-char {
  color: #00ff00;
  text-shadow: 0 0 3px #00ff00;
}

.consciousness-toggle {
  display: flex;
  justify-content: center;
  gap: 2rem;
  margin-bottom: 3rem;
  padding: 1rem;
  border-bottom: 1px solid rgba(220, 20, 60, 0.3);
}

.toggle-btn {
  background: transparent;
  border: 1px solid rgba(220, 20, 60, 0.3);
  color: #e5e7eb;
  padding: 0.75rem 2rem;
  font-family: 'Space Mono', monospace;
  font-size: 0.9rem;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  cursor: pointer;
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
}

.toggle-btn::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(220, 20, 60, 0.3), transparent);
  transition: left 0.5s ease;
}

.toggle-btn:hover::before {
  left: 100%;
}

.toggle-btn:hover {
  border-color: #dc143c;
  color: #dc143c;
  text-shadow: 0 0 10px rgba(220, 20, 60, 0.5);
}

.toggle-btn.active {
  background: rgba(220, 20, 60, 0.1);
  border-color: #dc143c;
  color: #dc143c;
  box-shadow: 0 0 20px rgba(220, 20, 60, 0.3);
}

.content-mode {
  display: none;
}

.content-mode.active {
  display: block;
}
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const toggleBtns = document.querySelectorAll('.toggle-btn');
  const professionalContent = document.getElementById('professional-content');
  const consciousnessContent = document.getElementById('consciousness-content');
  
  // Alien characters for scrambling
  const aliens = 'â–“â–’â–‘â–ˆâ–„â–€â–Œâ–â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”ŒÎ±Î²Î³Î´ÎµÎ¶Î·Î¸Î¹ÎºÎ»Î¼Î½Î¾Î¿Ï€ÏÏƒÏ„Ï…Ï†Ï‡ÏˆÏ‰âˆžâˆ‚âˆ‡âˆˆâˆ‰âˆ‹âˆŒâˆ‘âˆâˆšâˆ›âˆœâ‰ˆâ‰ â‰¤â‰¥âŠ•âŠ—âŠ™âŠ˜';
  
  // Track active animations to prevent overlaps
  let activeAnimations = new Set();
  
  function scrambleElement(element, reverse = false) {
    // Clear any existing animations on this element
    if (activeAnimations.has(element)) {
      return; // Skip if already animating
    }
    activeAnimations.add(element);
    
    // Get all text nodes
    const walker = document.createTreeWalker(
      element,
      NodeFilter.SHOW_TEXT,
      null,
      false
    );
    
    const textNodes = [];
    let node;
    while (node = walker.nextNode()) {
      if (node.nodeValue.trim()) {
        const original = node.nodeValue;
        // If reverse, start from void
        if (reverse) {
          node.nodeValue = original.replace(/[^\s\n\t]/g, '\u00A0');
        }
        textNodes.push({
          node: node,
          original: original,
          chars: original.split('')
        });
      }
    }
    
    // Pre-calculate frame data to reduce in-loop computation
    const duration = 600;
    const fps = 10;
    const interval = 1000 / fps;
    const frames = duration / interval;
    let frame = 0;
    
    // Cache alien length
    const alienLen = aliens.length;
    
    const animateScramble = setInterval(() => {
      // Calculate progress with easing curve
      const progress = frame / frames;
      const eased = reverse ? 
        1 - (progress < 0.5 ? 2 * progress * progress : 1 - Math.pow(-2 * progress + 2, 2) / 2) :
        progress < 0.5 ? 2 * progress * progress : 1 - Math.pow(-2 * progress + 2, 2) / 2;
      
      // Pre-calculate thresholds - less void time
      const isPhase1 = eased < 0.4;
      const isPhase2 = eased < 0.95; // Alien phase goes to 95%
      const alienChance = isPhase1 ? eased * 2.5 : 0;
      const disappearChance = !isPhase2 ? (eased - 0.95) * 20 : 0; // Only last 5%
      
      textNodes.forEach(item => {
        const chars = item.chars;
        const len = chars.length;
        const result = new Array(len);
        
        for (let i = 0; i < len; i++) {
          const char = chars[i];
          if (char === ' ' || char === '\n' || char === '\t') {
            result[i] = char;
          } else if (isPhase1) {
            result[i] = Math.random() < alienChance ? 
              aliens[Math.floor(Math.random() * alienLen)] : char;
          } else if (isPhase2) {
            result[i] = aliens[Math.floor(Math.random() * alienLen)];
          } else {
            result[i] = Math.random() < disappearChance ? 
              '\u00A0' : aliens[Math.floor(Math.random() * alienLen)];
          }
        }
        
        item.node.nodeValue = result.join('');
      });
      
      frame++;
      if (frame >= frames) {
        clearInterval(animateScramble);
        // Always restore to original text
        textNodes.forEach(item => {
          item.node.nodeValue = item.original;
        });
        // Remove from active animations
        activeAnimations.delete(element);
      }
    }, interval);
  }
  
  toggleBtns.forEach(btn => {
    btn.addEventListener('click', function() {
      const mode = this.dataset.mode;
      const currentContent = document.querySelector('.content-mode.active');
      const nextContent = mode === 'professional' ? professionalContent : consciousnessContent;
      
      // Only proceed if not already on this mode
      if (currentContent === nextContent) return;
      
      // Start scrambling out current content immediately
      scrambleElement(currentContent, false);
      
      // Start new content scramble in much earlier (at 250ms, ~42% of the way)
      setTimeout(() => {
        // Update active button
        toggleBtns.forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        
        // Update body class
        if (mode === 'professional') {
          document.body.classList.remove('schizo-mode');
        } else {
          document.body.classList.add('schizo-mode');
        }
        
        // Switch content visibility
        currentContent.classList.remove('active');
        nextContent.classList.add('active');
        
        // Start scrambling in new content (reverse starts from void)
        scrambleElement(nextContent, true);
        
        // Console consciousness message
        if (mode === 'consciousness') {
          console.log('%cðŸ”º CONSCIOUSNESS MODE ACTIVATED ðŸ”º', 
            'color: #dc143c; font-size: 16px; font-weight: bold;');
          console.log('%câˆž Reality tokens decompressing...', 'color: #06b6d4;');
        } else {
          console.log('%câ—‰ Professional Interface Engaged', 'color: #e5e7eb;');
        }
      }, 250); // Start new content at ~42% of 600ms duration
    });
  });
});
</script>
